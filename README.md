# C++ primer
## Chapter1
### 编译命令
```shell
g++ -o main *.cpp # 生成名为main的可执行文件
g++ *.cpp # 自动生成名为a.out的可执行文件
```
### 查看程序main函数return的结果
UNIX
```shell
echo $?
```
Windows
```shell
echo %ERRORLEVEL%
```
### C++11支持
可能需要指定`-std=c++0x`来打开
### 缓冲刷新
`std::endl`的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中，缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流
### istream对象作为条件
```cpp
while(std::cin >> value)
```
`>>` 是一个二元运算符，左侧是istream对象，右侧是输入，运算结果是左侧的istream对象（这使得连续>>成为可能）,上面的代码中，返回的istream对象成为了条件，此时效果是检测流的状态，如果流是有效的，即流未遇到错误，那么检测成功，当遇到**文件结束符**（end-of-file），或遇到一个无效的输入时（例如读入的不是一个value的类型的值），istream对象的状态会变为无效，此时作为条件为假
### 文件结束符
Windows中文件结束符是`Ctrl+Z`然后按回车，UNIX系统中（包括Mac OS X），文件结束符是Ctrl+D
### 头文件的<>和“”
<>包围来自标准库的头文件，""包围不属于标准库的头文件
## Chapter2
### 类型
C++定义了一套包括**算数类型**（arithmetic type）和**空类型**（void）在内的基本数据类型
### 选择类型的建议
* 明确知道不可能为负时，选用无符号类型
* 使用int执行整数运算，实际应用中，short常常太小而long一般和int有一样的尺寸，如果实际值超过了int的范围，选用long long
* 在算数表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出现问题。如果需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned char
* 执行浮点运算时选用double，因为float常常精度不够且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度的运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
### 浮点数转化为整数
保留小数点之前，不是四舍五入也不是向下取整
### 含有无符号的表达式
如果表达式中有int和无符号时，int会转化为无符号数
### 长字符串换行
这样的代码是合法的
```c++
cout << "aaaa"
  "bbb" << endl;
```
### 字面值对应类型
一般字面值的类型是能容纳该字面值的最小类型，比如12212121212，就是int、long、long long中能容纳它的最小的类型
### 指定字面值的类型
使用前缀或后缀指定字面值的类型
|前缀|含义|类型|
|---|---|---|
|u|Unicode 16字符|char16_t|
|U|Unicode 32字符|char32_t|
|L|宽字符|wchar_t|
|u8|UTF-8(仅用于字符串字面常量)|char|

整型字面值
|后缀|最小匹配类型|
|---|---|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|

浮点型字面值
|后缀|最小匹配类型|
|---|---|
|f或F|float|
|l或L|long double|
请尽量使用L作为long的代表，避免l和1的混淆
### 进制
以0开头是八进制数字，以0x或0X开头是16进制

### 初始化和赋值
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除而以一个新的值取代

### 列表初始化
四种初始化方法
```cpp
int a = 0;
int a = {0};
int a{0};
int a(0);
```
这种初始化的形式称为列表初始化（list initialization），当使用列表初始化且初始值存在丢失信息的风险时，编译器会报错：
```cpp
long double ld = 3.1415922653;
int a{ld}, b = {ld}; // 错误：转化未执行，因为存在信息丢失的危险
int c(ld), d= ld; // 正确：转换执行，且确实丢失了部分值
```
### 变量声明和定义
变量能且只能被定义一次，但是可以多次声明。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明
声明变量的方法：
```cpp
extern int i; // 声明
int i; // 定义
```
### c++的静态类型
C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型，其中检查类型的过程称为类型检查（type checking）

对象的类型决定了对象所能参与的运算，C++中，编译器负责检查数据类型是否支持要执行的运算，如果视图执行类型不支持的运算，编译器将报错且不会生成可执行文件。

程序越复杂，静态类型检查就越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。

### 标识符
c++的标识符由字母数字和下划线组成，其中必须以字母或下划线开头，长度没有限制，但对大小写敏感，用户自定义的标识符中不能连续出现两个下划线（自己试过却可以），不可以使用下划线紧连大写字母开头（自己试过却可以），定义在函数体外的标识符不能以下划线开头（自己试过却可以）

### 变量命名规范
* 体现实际含义
* 一般使用小写字母
* 用户自定义类以大写字母开头
* 如果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan

### 显式访问全局变量
```cpp
::global_var
```
### 复合类型
#### 引用
引用是一种符合类型，引用即别名
```cpp
int a = 1;
int &b = a;
```
引用只能绑定对象，不可以绑定字面值或表达式，且引用定义时就要绑定，初始化后将一直保持绑定，无法更改
```cpp
int &a = 1; // 错误
int &a; // 错误
```
注意此处的无法更改是指没有办法，如下的语句看似更改了引用
```cpp
int a = 1;
int &b = a;
int c = 2;
b = c;
```
但其实此时应将b看作a的别名，就是将c的值赋给a，而不是更改b的引用到c
#### 指针
指针也是一种复合类型，与引用类似，指针也实现了对其他对象的简介访问。不同之处在于
* 指针是一个对象，引用不是对象，指针允许对指针的赋值和拷贝，且可以指向不同对象
* 指针无需在定义时赋值
```cpp
int *ip1, *ip2;
```
注意：和引用一样，指针的*号写在变量名的前面构成声明符（declarator）

指针存放对象的地址，通过取地址符（&，与引用一样）定义
```cpp
int ival = 42;
int *p = &ival;
```
无论是指针或引用，常情况下应与指向的值类型匹配

通过解引用符（*）获得对象
```cpp
int ival = 42;
int *p = &ival;
cout << *p;
```
可见*和&的不同作用，作为运算符或者定义复合类型的符号

生成空指针的方法
```cpp
int *p1 = nullptr; // 推荐
int *p2 = 0;
int *p3 = NULL; // 尽量避免
```

**可能的情况下，初始化所有指针，否则因为指针未被初始化导致访问不明地址的值的错误很难检测出来,且会出现不可预计的结果**

void*指针可以指向任意类型的对象，但却因为不知道存储的是什么对象的地址而无法操作所指的对象
#### 指向指针的指针
```cpp
int **p;
```
#### 指向指针的引用
```cpp
int i = 42;
int *p;
int *&r = p;
```
从右向左读，右边的最重要
### 常量
```cpp
const int a = 10;
```
常量必须初始化且不可更改

常量引用是可以使用字面值初始化引用的一个例外
```cpp
int i = 42;
const int &r = 42;
```
此时编译器会生成一个temp对象，实际上引用的是该temp对象

允许通过常量引用一个非常量对象，反之则不行，这种行为是合法的，但无法通过引用来更改对象

允许使用指向常量指针来指向一个非常量对象，反之则不行，这也仅仅要求了不可以通过常量指针来更改对象

常量指针
```cpp
int errNumb = 0;
int *const curErr = &errNumb;
```
常量指针与指向常量的指针不同，常量指针意味着不可更改的是指针指向的地址而不是指针指向的常量的值

#### 顶层const和底层const
顶层const就是指针是常量

底层const就是指针指向的是常量
### 常量表达式
constexpr变量，常量表达式就指值不会改变并且在编译过程中就能得到计算结果的表达式，可以将变量声明为constexpr类型来验证变量的值是否是一个常量表达式


### 类型别名
通过以下方法可以定义类型别名
```cpp
typedef double wages; // wages是double的同义词
typedef wages base, *p; // base戳double的同义词，p是double*的同义词
```
新标准的**别名声明（alias declaration）**
```cpp
using SI = Sales_item;
```

使用别名后的一个误区
```cpp
typedef char *pstring;
const pstring cstr = 0;
const char *cstr = 0;
```
第二行和第三行并不一样，前者是指向char的常量指针，后者是指向const char的指针

### auto类型说明符
auto可以让编译器分析变量的类型

### decltype
如果只想得到某个变量的类型，可以通过decltype完成，甚至可以取函数的返回值，这个过程不会实际执行函数
```cpp
char f(int a){
  while(true){
    return 'c';
  }
}

decltype(f(1)) a = 'w';
```

`decltype((变量))`加双层括号的结果永远是引用类型

## 头文件
头文件需要设置保护符
```
#ifndef blabla
#define blabla
...
#endif
```
## 常见错误
### float的字面值
```cpp
cout << 1024f << endl;
```
f直接跟在整数后面，应该改成1024.f
### 指针类型
```cpp
int* a,b;
```
这是合法的写法，但b并非是指针，只是一个int的值

## Chapter3
### 命名空间的using声明
通过使用using声明，即可避免反复输入std::
```cpp
using std::cin; using std::cout;
```
声明以分号结尾，一行可以写多个

### string
string是可变长的字符序列，使用方法如下
```cpp
#include<string>
using std::string
```
#### 初始化
```cpp
string s1 = "aanb";
string s2(10, 'c'); // 'cccccccccc' 
```
直接初始化和拷贝初始化
```cpp
string s1 = "aabn"; // 拷贝初始化
string s2("aabn"); // 直接初始化
```
对上面的例子来说是一样的，但当使用多个值来初始化时
```cpp
string s1 = string(3,'c'); // 直接初始化
string s2(3,'c'); // 拷贝初始化
```
因为c++中使用等号初始化是拷贝初始化的方式，相比而言，使用多个变量初始化的时候，推荐还是使用直接初始化方法

#### 读写
string接受输入时会自动忽略开头的空白（空格、换行、制表符等），读到下一个空白的位置

可以使用getline读取一整行，读到换行符结束，并丢弃掉该换行符
```cpp
string s;
getline(cin,s); //读取一整行
```
#### empty size
string.empty()和string.size()
注意string.size()返回的是一个string::size_type的无符号数，这意味着不能随意对这个数和int型数进行计算
#### string.func()
书p82
#### 处理每个字符
```cpp
string s = "asd";
for(auto &c:){
  c = 'w';
}
```
### vector
#### 声明
#include<vector>
using std::vector;
#### 初始化
```cpp
vector<T> a(n,val);
vector<T> a = {a,b,c};
```
花括号和圆括号
```cpp
vecotr<int> v1(10); // 10个元素，每个都是默认值
vector<int> v2{10}; // 1个10
```
#### 添加元素
```cpp
vector.push_back
```
#### 成员函数
```cpp
vector.size() // vector 元素个数
vector.empty() // vector 是否为空
```
#### 效率
vector能高效增长，因此定义vector时预先设置其大小没有太多必要，且这样做有时效果可能适得其反
#### 索引
可以通过索引访问元素，但不能用索引添加元素，只能用索引修改元素
#### auto
使用auto来遍历vector也是很方便的
```cpp
vector<string> s = {........};
for(auto c:s){
  cout << c;  
}
```
### 迭代器
* c++迭代器和python迭代器有什么区别？
  c++的迭代器是类似一个指针的东西，迭代器指向元素，且可以随意更改迭代器指向的位置，python的迭代器是实现了__iter__的类，且python的迭代器不可以随意更改指向元素的位置
* python的可迭代对象和迭代器有什么区别？
  回去查书...
* 有了范围for之后，还要迭代器干嘛？
  范围for针对当前的元素，丧失了下标索引的灵活性，而迭代器则保持了这个灵活性，在迭代器中的不同位置元素需要交互时，使用迭代器或者索引更好，仅仅对单个元素进行操作时，使用范围for更好

标准库定义了很多容器，包括string，所有标准库的容器都可以使用迭代器，但其中少数才同时支持下标运算符

#### 使用迭代器
通过.begin和.end来使用迭代器
```cpp
string s = "12334";
for(auto it=s.begin();it!=s.end();++it){
  *it = toupper(*t);
}
```
迭代器类似指针，需解引用来访问元素

#### 泛型编程
c++中循环一般使用!=而非<，这是因为这样的判断对所有标准库容器都有效

#### 常量迭代器
.cbegin和.cend返回的是常量迭代器，其中的元素不可变

#### 箭头
为了访问迭代器指向的元素，需要解引用，同时，有时我们要访问指向对象的成员函数，就会这样写
```cpp
(*p).empty();
```
这样十分麻烦，c++中的箭头就是一种替代写法，它同时进行解引用和成员访问
```cpp
p->empty();
```
#### 迭代器运算
迭代器支持与常数的+ - 运算，以及迭代器之间的减法运算

### 数组
数组类似vector，不同的是不能向数组中任意添加元素，必须声明数组大小，但也可以通过列表初始化省略声明
```cpp
char a[10];
int b[] = {1,23,4,5};
char c[3] = "AK"; // c[2]是'\0'
```
#### 指针和数组
使用数组的时候编译器会将其变成一个指针

推导类型不同
```cpp
int a[10];
auto b = a; // b是指针
decltype(a) c; // c是数组 
```

#### 指针也是迭代器
因为指针不是类，可以通过begin(),end()函数获得迭代器
```cpp
for(auto it=begin(a);it!=end(i);it++){
  // do something
}
```

#### 下标
数组的下标可以是负值相当于指针向前移位

### C风格字符串
c风格字符串包括在cstring头文件中，是string.h的c++版本，字符串在字符数组中，最后一个元素是'\0'，一般来说，使用string比使用c风格字符串更简洁高效

### 与旧代码的接口
允许用以空字符结束的字符数组来初始化string，反过来不行，但可以使用s.c_str()将字符串转化为c风格字符串

可以同数组来初始化vector对象
```cpp
int a[] = {1,2,3};
vector<int> ivec(begin(a),end(a));
```

**使用指针和数据容易出错，因为它们属于底层操作，现代c++程序应当尽量使用vector和迭代器，尽量使用string**

### 多维数组
多维数组初始化
```cpp
int a[2][2] = {
  {1,2},
  {3,4}
};
int b[2][2] = {1,2,3,4};
```

使用范围for来遍历数组
```
for(auto &row:a)
  for(auto &cal:row){
    //do something
  }
```
这是针对需要改变数组元素的范围for，使用了引用，但实际上，还有别的原因驱使我们使用引用，这是为了避免数组被自动转化为指针，如果不使用引用，程序无法通过编译

**如果对多维数组使用范围for，除了最内层的训练，其他所有循环都需要使用引用类型**

```cpp
int *p[4]; // 数组的指针
int (*p)[4]; // 指针的数组
```

新标准类别声明
```
using int_array = int[4];
```

## 表达式
### 基础
#### 左值和右值
c语言中，两者区别简记为：左值可以位于赋值语句的左侧，右值则不能
c++中：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）

decltype对左值和右值的结果都不同，如果表达式的求值结果是左值，decltype则得到一个引用类型，比如假设p类型是int\*，因为解引用得到的是左值，因此decltype(*p)的结果是int &，因为取地址算法生成右值所以decltype(&p)的结果是int\*\*？？（是不是反了？？）

赋值运算符左侧必须是左值，有侧可左可右

#### 求值顺序
c++大多数情况没有规定二元运算符的求值顺序比如
```cpp
int i = f1() * f2();
```
f1和f2都会在乘法之前计算，但是具体计算顺序是未知的，这也引入一个问题
```cpp
int i = 0;
cout << i << " " << ++i << endl;
```
上式也是未定义行为

但c++中有四种运算符明确规定了运算对象的求值顺序，就是逻辑与（&&）逻辑（||）条件（?:）和逗号（，）

所以对于大多数运算符的使用，应该遵守两个准则
* 不确定运算顺序时，使用括号
* 不要在表达式中同事改变并再次使用某个对象

### 算术运算符
优先级相同情况下，二元运算符均满足左结合律

/是整除，只要两边都是整数，根据C++11规定，均向0取整

%是取余数，其符号由左边的数决定

### 逻辑关系运算符
逻辑与和逻辑或均采用**短路求值**的方法，逻辑与仅当左边为真时计算右边，逻辑或仅当左边为假时计算右边

**使用引用可以避免程序对变量的拷贝，对于大型变量来说这样做能提高程序效率**

### 赋值运算符
赋值运算符满足右结合率，这是区别于其他二元运算符的特征

### 递增和递减运算符
除非必须，否则不使用递增递减运算符的后置版本

但为了简洁可以写
```cpp
cout << *iter++;
```

它对iter解引用，输出后将迭代器指针向后移一位

### 条件运算符
条件运算符`?:`将简单的if-else嵌套到单个表达式中，还可以嵌套
```
string finalgrade = (grade>90)?"high pass":(grade < 60) ?"fail":"pass";
```
条件运算符是右结合的，因此嵌套才有意义

### sizeof 运算符
可以求类型所占的字节数，与decltype一样，不会运行得到结果

sizeof数组可以得到数组的大小

### 逗号运算符
逗号运算符有两个运算对象，且和逻辑与、逻辑或以及条件运算符一样，规定了运算的求值顺序：从左到右

逗号运算符先求左侧表达式，然后把表达式结果丢掉，再求右侧表达式，作为求值结果

### 类型转换
不同类型对象进行运算时，会发生类型转换，此时小的类型会提升为大的类型

### 显式转换
强制类型转换的使用方法是

`cast-name<type>(expression)`

其中，cast-name包括

* static_cast
* const_cast
* reinterpret_cast

旧式转化方法为`type(expr)`或`(type)expr`

**慎用类型转换，因为它会干扰正常的类型检查**